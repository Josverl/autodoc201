# Testground from Micropython Documentation

To Implement this the following steps are needed 

 [ ] Create a documentation guide that helps contributers decide how to best document things. This can also be used as the basis to create Jinja templates that are used by AutoAPI.
 [ ] Select the relevant type-stubs and add them to the micropython repo 
  ( docs/stubs/library)
 [x] Add the Sphinx AutoAPI and relevant configuration 
 [x] Customize AutoAPI's jinja templates used to generate documentation 
 [ ] Update the existing .rST documents.
  Per document in docs/library:
  - Update the variuous python refencences to their autoapi equivalents:
    - `.. module::` --> `.. autoapimodule::`
    - `.. function::`-->`.. autoapifunction::`
    - `.. class::`-->`.. autoapiclass::`
    - etc...
  - Remove associated details for that topic 
  - regenerate the docs using `make -C ./docs`
  - check for errors and completeness

 [ ] Docstring pre-processing to 
    [ ] clean up some of the module/class docstrings 
    [x] mark the classes that originate from micropython-lib
    [ ] add port desognations (need source for that)

 [ ] add logic to add the micropython-lib modules 
 [ ] 

## Autodoc-Style Directives

You can opt to write API documentation yourself using autodoc style directives. These directives work similarly to autodoc, but docstrings are retrieved through static analysis instead of through imports.
For Python, all directives have an autodoc equivalent and accept the same options. The following directives are available:

.. autoapimodule::
.. autoapiclass::
.. autoapiexception::

Equivalent to automodule, autoclass, and autoexception respectively. autodoc_inherit_docstrings does not currently work.

.. autoapifunction::
.. autoapidata::
.. autoapimethod::
.. autoapiattribute::

Equivalent to autofunction, autodata, automethod, and autoattribute respectively.

see: https://sphinx-autoapi.readthedocs.io/en/latest/reference/directives.html


.. autoapimodule:: array
    :noindex:
    :members:
    :undoc-members:
    :private-members: 

    :special-members:



    :exclude-members: __init__, __weakref__

.. restore_section::


   .. autoapiclass:: btree
        :noindex:
        :members:
        :undoc-members:
        :private-members: 
        :special-members:
        :show-inheritance:



### check example codeblocks for \n or \n 

all special charactes should have an extra `\` so `\n` should be `\\n`


### move class __init__ methods to the first method in the class
stubber places the `__init__` method at the end of the class, but it is more common to see it at the top of the class
Apparently autoAPI assumes __init__ is always the first method in the class, so it is better to move it there
if not the class will not be documented properly


# to we keep all the module pages generated by autodocs ?
Currently the library pages mix regular documentation and module/class documation in the same page 
This is not ideal, as the module/class documentation is not easily accessible

There are multiple options to fix this:
1) keep the Why and How parts of the page and add links to the autoapi module or class pages in the autodocs
2) remove the autodoc pages and only use the autoapi pages


### index / no-index
as nowits even more likely that the autoapi pages will be the main source of information, it is important to be able to control which modules and classes are included in the index page and search.
With the `:noindex:` (or `:no-index:`? ) option, the module or class will not be included in the index page. This is useful for modules that are not part of the standard library, but are included in the documentation for reference purposes.

I hove ot (yet) found a way to control the no-index attribute of the pages generated by autoapi, 
therefore I have been marking the modules/classesand functios in teh `library/foobar.rts` files with the `.. no-index::` directive to prevent them from being included in the index page, anfd generating warnigs 



## Micropython-lib 

Some of the modules have docstrings and some level of type annotation, but most are quite poorly documented, possibly to try to save space on the microcontroller.


Option 1) Direct processing 
    - copy module from micropython-lib to a temporary location
    - generate documentation using autoAPI 
    - add logic to mark the modules as originating fro micropython-lib 

Option 2) dynamically create type-stubs 
    - use stubber to generate type stubs for all micropython-lib modules (using mypy-stubgen and some post processing toclean up its mistakes) 
      this is alrady done for all modules that are frozen in the micropython firmware.
      The benefit is better typennotation
    - add the type stubs to a temporary location
    - generate documentation using autoAPI 
    - add logic to mark the modules as originating fro micropython-lib 

Option3) add type-stubs to micropython-lib
    - Generate once - then maintain manually
    - add logic to mark the modules as originating from micropython-lib 
    - generate documentation using autoAPI
    Pro: best option for rich documentation withouth overhaed on the modules 
    con: manual maintenance of the type-stubs needed 


Note: 
  both docstrings, type annotations and comments are stripped during compilation , so for cross compiled modules thrae is no real difference AFAIK.






