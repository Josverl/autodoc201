_rp2
====

.. py:module:: _rp2

.. autoapi-nested-parse::

   Functionality specific to the RP2.

   MicroPython module: https://docs.micropython.org/en/v1.21.0/library/rp2.html

   The ``rp2`` module contains functions and classes specific to the RP2040, as
   used in the Raspberry Pi Pico.

   See the `RP2040 Python datasheet
   <https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf>`_
   for more information, and `pico-micropython-examples
   <https://github.com/raspberrypi/pico-micropython-examples/tree/master/pio>`_
   for example code.



Classes
-------

.. autoapisummary::

   _rp2.Flash
   _rp2.PIO
   _rp2.StateMachine


Functions
---------

.. autoapisummary::

   _rp2.bootsel_button


Package Contents
----------------

.. py:class:: Flash

   Gets the singleton object for accessing the SPI flash memory.


   .. py:method:: ioctl(cmd, arg) -> _typeshed.Incomplete

      These methods implement the simple and extended
      :ref:`block protocol <block-device-interface>` defined by
      :class:`os.AbstractBlockDev`.



   .. py:method:: readblocks(block_num, buf, offset: Optional[int] = 0) -> _typeshed.Incomplete


   .. py:method:: writeblocks(block_num, buf, offset: Optional[int] = 0) -> _typeshed.Incomplete


.. py:class:: PIO(id)

   Gets the PIO instance numbered *id*. The RP2040 has two PIO instances,
   numbered 0 and 1.

   Raises a ``ValueError`` if any other argument is provided.


   .. py:method:: add_program(program) -> _typeshed.Incomplete

      Add the *program* to the instruction memory of this PIO instance.

      The amount of memory available for programs on each PIO instance is
      limited. If there isn't enough space left in the PIO's program memory
      this method will raise ``OSError(ENOMEM)``.



   .. py:method:: irq(handler=None, trigger=IRQ_SM0, hard=False) -> _typeshed.Incomplete

      Returns the IRQ object for this PIO instance.

      MicroPython only uses IRQ 0 on each PIO instance. IRQ 1 is not available.

      Optionally configure it.



   .. py:method:: remove_program(program: Optional[Any] = None) -> None

      Remove *program* from the instruction memory of this PIO instance.

      If no program is provided, it removes all programs.

      It is not an error to remove a program which has already been removed.



   .. py:method:: state_machine(id, program, *args, **kwargs) -> _typeshed.Incomplete

      Gets the state machine numbered *id*. On the RP2040, each PIO instance has
      four state machines, numbered 0 to 3.

      Optionally initialize it with a *program*: see `StateMachine.init`.

      >>> rp2.PIO(1).state_machine(3)
      StateMachine(7)



   .. py:attribute:: IN_HIGH
      :type:  int


   .. py:attribute:: IN_LOW
      :type:  int


   .. py:attribute:: IRQ_SM0
      :type:  int


   .. py:attribute:: IRQ_SM1
      :type:  int


   .. py:attribute:: IRQ_SM2
      :type:  int


   .. py:attribute:: IRQ_SM3
      :type:  int


   .. py:attribute:: JOIN_NONE
      :type:  int


   .. py:attribute:: JOIN_RX
      :type:  int


   .. py:attribute:: JOIN_TX
      :type:  int


   .. py:attribute:: OUT_HIGH
      :type:  int


   .. py:attribute:: OUT_LOW
      :type:  int


   .. py:attribute:: SHIFT_LEFT
      :type:  int


   .. py:attribute:: SHIFT_RIGHT
      :type:  int


.. py:class:: StateMachine(id, program=None, freq=-1, *, in_base=None, out_base=None, set_base=None, jmp_pin=None, sideset_base=None, in_shiftdir=None, out_shiftdir=None, push_thresh=None, pull_thresh=None)

   Get the state machine numbered *id*. The RP2040 has two identical PIO
   instances, each with 4 state machines: so there are 8 state machines in
   total, numbered 0 to 7.

   Optionally initialize it with the given program *program*: see
   `StateMachine.init`.


   .. py:method:: active(value: Optional[Any] = None) -> _typeshed.Incomplete

      Gets or sets whether the state machine is currently running.

      >>> sm.active()
      True
      >>> sm.active(0)
      False



   .. py:method:: exec(instr) -> _typeshed.Incomplete

      Execute a single PIO instruction.

      If *instr* is a string then uses `asm_pio_encode` to encode the instruction
      from the given string.

      >>> sm.exec("set(0, 1)")

      If *instr* is an integer then it is treated as an already encoded PIO
      machine code instruction to be executed.

      >>> sm.exec(rp2.asm_pio_encode("out(y, 8)", 0))



   .. py:method:: get(buf=None, shift=0) -> _typeshed.Incomplete

      Pull a word from the state machine's RX FIFO.

      If the FIFO is empty, it blocks until data arrives (i.e. the state machine
      pushes a word).

      The value is shifted right by *shift* bits before returning, i.e. the
      return value is ``word >> shift``.



   .. py:method:: init(program, freq=-1, *, in_base=None, out_base=None, set_base=None, jmp_pin=None, sideset_base=None, in_shiftdir=None, out_shiftdir=None, push_thresh=None, pull_thresh=None) -> None

      Configure the state machine instance to run the given *program*.

      The program is added to the instruction memory of this PIO instance. If the
      instruction memory already contains this program, then its offset is
      re-used so as to save on instruction memory.

      - *freq* is the frequency in Hz to run the state machine at. Defaults to
        the system clock frequency.

        The clock divider is computed as ``system clock frequency / freq``, so
        there can be slight rounding errors.

        The minimum possible clock divider is one 65536th of the system clock: so
        at the default system clock frequency of 125MHz, the minimum value of
        *freq* is ``1908``. To run state machines at slower frequencies, you'll
        need to reduce the system clock speed with `machine.freq()`.
      - *in_base* is the first pin to use for ``in()`` instructions.
      - *out_base* is the first pin to use for ``out()`` instructions.
      - *set_base* is the first pin to use for ``set()`` instructions.
      - *jmp_pin* is the first pin to use for ``jmp(pin, ...)`` instructions.
      - *sideset_base* is the first pin to use for side-setting.
      - *in_shiftdir* is the direction the ISR will shift, either
        `PIO.SHIFT_LEFT` or `PIO.SHIFT_RIGHT`.
      - *out_shiftdir* is the direction the OSR will shift, either
        `PIO.SHIFT_LEFT` or `PIO.SHIFT_RIGHT`.
      - *push_thresh* is the threshold in bits before auto-push or conditional
        re-pushing is triggered.
      - *pull_thresh* is the threshold in bits before auto-pull or conditional
        re-pulling is triggered.



   .. py:method:: irq(handler=None, trigger=0 | 1, hard=False) -> _typeshed.Incomplete

      Returns the IRQ object for the given StateMachine.

      Optionally configure it.



   .. py:method:: put(value, shift=0) -> _typeshed.Incomplete

      Push words onto the state machine's TX FIFO.

      *value* can be an integer, an array of type ``B``, ``H`` or ``I``, or a
      `bytearray`.

      This method will block until all words have been written to the FIFO.  If
      the FIFO is, or becomes, full, the method will block until the state machine
      pulls enough words to complete the write.

      Each word is first shifted left by *shift* bits, i.e. the state machine
      receives ``word << shift``.



   .. py:method:: restart() -> _typeshed.Incomplete

      Restarts the state machine and jumps to the beginning of the program.

      This method clears the state machine's internal state using the RP2040's
      ``SM_RESTART`` register. This includes:

       - input and output shift counters
       - the contents of the input shift register
       - the delay counter
       - the waiting-on-IRQ state
       - a stalled instruction run using `StateMachine.exec()`



   .. py:method:: rx_fifo() -> int

      Returns the number of words in the state machine's RX FIFO. A value of 0
      indicates the FIFO is empty.

      Useful for checking if data is waiting to be read, before calling
      `StateMachine.get()`.



   .. py:method:: tx_fifo() -> int

      Returns the number of words in the state machine's TX FIFO. A value of 0
      indicates the FIFO is empty.

      Useful for checking if there is space to push another word using
      `StateMachine.put()`.



.. py:function:: bootsel_button() -> _typeshed.Incomplete

   Temporarily turns the QSPI_SS pin into an input and reads its value,
   returning 1 for low and 0 for high.
   On a typical RP2040 board with a BOOTSEL button, a return value of 1
   indicates that the button is pressed.

   Since this function temporarily disables access to the external flash
   memory, it also temporarily disables interrupts and the other core to
   prevent them from trying to execute code from flash.


