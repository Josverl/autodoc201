machine.I2C
===========

.. py:module:: machine.I2C


Classes
-------

.. autoapisummary::

   machine.I2C.I2C
   machine.I2C.SoftI2C


Module Contents
---------------

.. py:class:: I2C(id: Union[int, str] = -1, *, scl: Optional[Union[machine.Pin.Pin, str]] = None, sda: Optional[Union[machine.Pin.Pin, str]] = None, freq=400000, timeout=50000)

   Construct and return a new I2C object using the following parameters:

      - *id* identifies a particular I2C peripheral.  Allowed values for
        depend on the particular port/board
      - *scl* should be a pin object specifying the pin to use for SCL.
      - *sda* should be a pin object specifying the pin to use for SDA.
      - *freq* should be an integer which sets the maximum frequency
        for SCL.
      - *timeout* is the maximum time in microseconds to allow for I2C
        transactions.  This parameter is not allowed on some ports.

   Note that some ports/boards will have default values of *scl* and *sda*
   that can be changed in this constructor.  Others will have fixed values
   of *scl* and *sda* that cannot be changed.


   .. py:method:: deinit() -> None

      Turn off the I2C bus.

      Availability: WiPy.



   .. py:method:: init(scl, sda, *, freq=400000) -> None

      Initialise the I2C bus with the given arguments:

         - *scl* is a pin object for the SCL line
         - *sda* is a pin object for the SDA line
         - *freq* is the SCL clock rate

       In the case of hardware I2C the actual clock frequency may be lower than the
       requested frequency. This is dependent on the platform hardware. The actual
       rate may be determined by printing the I2C object.



   .. py:method:: readfrom(addr, nbytes, stop=True) -> bytes

      Read *nbytes* from the peripheral specified by *addr*.
      If *stop* is true then a STOP condition is generated at the end of the transfer.
      Returns a `bytes` object with the data read.



   .. py:method:: readfrom_into(addr, buf, stop=True) -> None

      Read into *buf* from the peripheral specified by *addr*.
      The number of bytes read will be the length of *buf*.
      If *stop* is true then a STOP condition is generated at the end of the transfer.

      The method returns ``None``.



   .. py:method:: readfrom_mem(addr, memaddr, nbytes, *, addrsize=8) -> bytes

      Read *nbytes* from the peripheral specified by *addr* starting from the memory
      address specified by *memaddr*.
      The argument *addrsize* specifies the address size in bits.
      Returns a `bytes` object with the data read.



   .. py:method:: readfrom_mem_into(addr, memaddr, buf, *, addrsize=8) -> None

      Read into *buf* from the peripheral specified by *addr* starting from the
      memory address specified by *memaddr*.  The number of bytes read is the
      length of *buf*.
      The argument *addrsize* specifies the address size in bits (on ESP8266
      this argument is not recognised and the address size is always 8 bits).

      The method returns ``None``.



   .. py:method:: readinto(buf, nack=True) -> _typeshed.Incomplete

      Reads bytes from the bus and stores them into *buf*.  The number of bytes
      read is the length of *buf*.  An ACK will be sent on the bus after
      receiving all but the last byte.  After the last byte is received, if *nack*
      is true then a NACK will be sent, otherwise an ACK will be sent (and in this
      case the peripheral assumes more bytes are going to be read in a later call).



   .. py:method:: scan() -> List

      Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list of
      those that respond.  A device responds if it pulls the SDA line low after
      its address (including a write bit) is sent on the bus.



   .. py:method:: start() -> None

      Generate a START condition on the bus (SDA transitions to low while SCL is high).



   .. py:method:: stop() -> None

      Generate a STOP condition on the bus (SDA transitions to high while SCL is high).



   .. py:method:: write(buf) -> int

      Write the bytes from *buf* to the bus.  Checks that an ACK is received
      after each byte and stops transmitting the remaining bytes if a NACK is
      received.  The function returns the number of ACKs that were received.



   .. py:method:: writeto(addr, buf, stop=True) -> int

      Write the bytes from *buf* to the peripheral specified by *addr*.  If a
      NACK is received following the write of a byte from *buf* then the
      remaining bytes are not sent.  If *stop* is true then a STOP condition is
      generated at the end of the transfer, even if a NACK is received.
      The function returns the number of ACKs that were received.



   .. py:method:: writeto_mem(addr, memaddr, buf, *, addrsize=8) -> None

      Write *buf* to the peripheral specified by *addr* starting from the
      memory address specified by *memaddr*.
      The argument *addrsize* specifies the address size in bits (on ESP8266
      this argument is not recognised and the address size is always 8 bits).

      The method returns ``None``.



   .. py:method:: writevto(addr, vector, stop=True) -> int

      Write the bytes contained in *vector* to the peripheral specified by *addr*.
      *vector* should be a tuple or list of objects with the buffer protocol.
      The *addr* is sent once and then the bytes from each object in *vector*
      are written out sequentially.  The objects in *vector* may be zero bytes
      in length in which case they don't contribute to the output.

      If a NACK is received following the write of a byte from one of the
      objects in *vector* then the remaining bytes, and any remaining objects,
      are not sent.  If *stop* is true then a STOP condition is generated at
      the end of the transfer, even if a NACK is received.  The function
      returns the number of ACKs that were received.



.. py:class:: SoftI2C(scl, sda, *, freq=400000, timeout=50000)

   Bases: :py:obj:`I2C`


   Construct a new software I2C object.  The parameters are:

      - *scl* should be a pin object specifying the pin to use for SCL.
      - *sda* should be a pin object specifying the pin to use for SDA.
      - *freq* should be an integer which sets the maximum frequency
        for SCL.
      - *timeout* is the maximum time in microseconds to wait for clock
        stretching (SCL held low by another device on the bus), after
        which an ``OSError(ETIMEDOUT)`` exception is raised.


